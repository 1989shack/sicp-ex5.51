### Language Support
None.  Not in the book. 

### Related Implementation

The following procedures have analagous functions in the implementation:

    open-input-file	Filename
        => struct in_port *open_input_file(char *);
  
    close-input-port port
        => int close_input_port(struct in_port *);
  
    read-char port		
        => int read_char(struct in_port *);
  
--------------------------------------------------------------------------------
## R4RS:

### 6.10 Input and output

#### 6.10.1 Ports

Ports represent input and output devices. To Scheme, an input port is a
Scheme object that can deliver characters upon command, while an output port
is a Scheme object that can accept characters.

##### essential procedure: call-with-input-file string proc
##### essential procedure: call-with-output-file string proc

Proc should be a procedure of one argument, and string should be a string
naming a file. For call-with-input-file, the file must already exist; for
call-with-output-file, the effect is unspecified if the file already exists.
These procedures call proc with one argument: the port obtained by opening
the named file for input or output. If the file cannot be opened, an error
is signalled. If the procedure returns, then the port is closed
automatically and the value yielded by the procedure is returned. If the
procedure does not return, then the port will not be closed automatically
unless it is possible to prove that the port will never again be used for a
read or write operation.

Rationale: Because Scheme's escape procedures have unlimited extent, it is
possible to escape from the current continuation but later to escape back
in. If implementations were permitted to close the port on any escape from
the current continuation, then it would be impossible to write portable code
using both call-with-current-continuation and call-with-input-file or
call-with-output-file.

##### essential procedure: input-port? obj
##### essential procedure: output-port? obj

Returns #t if obj is an input port or output port respectively, otherwise
returns #f.

##### essential procedure: current-input-port
##### essential procedure: current-output-port

Returns the current default input or output port. procedure:
with-input-from-file string thunk procedure: with-output-to-file string
thunk

Thunk must be a procedure of no arguments, and string must be a string
naming a file. For with-input-from-file, the file must already exist; for
with-output-to-file, the effect is unspecified if the file already exists.
The file is opened for input or output, an input or output port connected to
it is made the default value returned by current-input-port or
current-output-port, and the thunk is called with no arguments. When the
thunk returns, the port is closed and the previous default is restored.
With-input-from-file and with-output-to-file return the value yielded by
thunk. If an escape procedure is used to escape from the continuation of
these procedures, their behavior is implementation dependent.

##### essential procedure: open-input-file filename

Takes a string naming an existing file and returns an input port capable of
delivering characters from the file. If the file cannot be opened, an error
is signalled.

##### essential procedure: open-output-file filename

Takes a string naming an output file to be created and returns an output
port capable of writing characters to a new file by that name. If the file
cannot be opened, an error is signalled. If a file with the given name
already exists, the effect is unspecified.

##### essential procedure: close-input-port port
##### essential procedure: close-output-port port

Closes the file associated with port, rendering the port incapable of delivering or accepting characters.

These routines have no effect if the file has already been closed. The value
returned is unspecified.

#### 6.10.2 Input

##### essential procedure: read
##### essential procedure: read port

Read converts external representations of Scheme objects into the objects
themselves. That is, it is a parser for the nonterminal <datum> (see
sections see section 7.1.2 External representations and see section 6.3
Pairs and lists). Read returns the next object parsable from the given input
port, updating port to point to the first character past the end of the
external representation of the object.

If an end of file is encountered in the input before any characters are
found that can begin an object, then an end of file object is returned. The
port remains open, and further attempts to read will also return an end of
file object. If an end of file is encountered after the beginning of an
object's external representation, but the external representation is
incomplete and therefore not parsable, an error is signalled.

The port argument may be omitted, in which case it defaults to the value
returned by current-input-port. It is an error to read from a closed port.

##### essential procedure: read-char
##### essential procedure: read-char port

Returns the next character available from the input port, updating the port
to point to the following character. If no more characters are available, an
end of file object is returned. Port may be omitted, in which case it
defaults to the value returned by current-input-port.

##### essential procedure: peek-char
##### essential procedure: peek-char port

Returns the next character available from the input port, without updating
the port to point to the following character. If no more characters are
available, an end of file object is returned. Port may be omitted, in which
case it defaults to the value returned by current-input-port.

Note: The value returned by a call to peek-char is the same as the value
that would have been returned by a call to read-char with the same port. The
only difference is that the very next call to read-char or peek-char on that
port will return the value returned by the preceding call to peek-char. In
particular, a call to peek-char on an interactive port will hang waiting for
input whenever a call to read-char would have hung.

##### essential procedure: eof-object? obj

Returns #t if obj is an end of file object, otherwise returns #f. The
precise set of end of file objects will vary among implementations, but in
any case no end of file object will ever be an object that can be read in
using read.

##### procedure: char-ready?
##### procedure: char-ready? port

Returns #t if a character is ready on the input port and returns #f
otherwise. If char-ready returns #t then the next read-char operation on the
given port is guaranteed not to hang. If the port is at end of file then
char-ready? returns #t. Port may be omitted, in which case it defaults to
the value returned by current-input-port.

Rationale: Char-ready? exists to make it possible for a program to accept
characters from interactive ports without getting stuck waiting for input.
Any input editors associated with such ports must ensure that characters
whose existence has been asserted by char-ready? cannot be rubbed out. If
char-ready? were to return #f at end of file, a port at end of file would be
indistinguishable from an interactive port that has no ready characters.

#### 6.10.3 Output

##### essential procedure: write obj
##### essential procedure: write obj port

Writes a written representation of obj to the given port. Strings that
appear in the written representation are enclosed in doublequotes, and
within those strings backslash and doublequote characters are escaped by
backslashes. Write returns an unspecified value. The port argument may be
omitted, in which case it defaults to the value returned by
current-output-port.

##### essential procedure: display obj
##### essential procedure: display obj port

Writes a representation of obj to the given port. Strings that appear in the
written representation are not enclosed in doublequotes, and no characters
are escaped within those strings. Character objects appear in the
representation as if written by write-char instead of by write. Display
returns an unspecified value. The port argument may be omitted, in which
case it defaults to the value returned by current-output-port.

Rationale: Write is intended for producing machine-readable output and
display is for producing human-readable output. Implementations that allow
"slashification" within symbols will probably want write but not display to
slashify funny characters in symbols.

##### essential procedure: newline
##### essential procedure: newline port

Writes an end of line to port. Exactly how this is done differs from one
operating system to another. Returns an unspecified value. The port argument
may be omitted, in which case it defaults to the value returned by
current-output-port.

##### essential procedure: write-char char
##### essential procedure: write-char char port

Writes the character char (not an external representation of the character)
to the given port and returns an unspecified value. The port argument may be
omitted, in which case it defaults to the value returned by
current-output-port.

#### 6.10.4 System interface

Questions of system interface generally fall outside of the domain of this
report. However, the following operations are important enough to deserve
description here.

##### essential procedure: load filename

Filename should be a string naming an existing file containing Scheme source
code. The load procedure reads expressions and definitions from the file and
evaluates them sequentially. It is unspecified whether the results of the
expressions are printed. The load procedure does not affect the values
returned by current-input-port and current-output-port. Load returns an
unspecified value.

Rationale: For portability, load must operate on source files. Its operation
on other kinds of files necessarily varies among implementations.

##### procedure: transcript-on filename
##### procedure: transcript-off

Filename must be a string naming an output file to be created. The effect of
transcript-on is to open the named file for output, and to cause a
transcript of subsequent interaction between the user and the Scheme system
to be written to the file. The transcript is ended by a call to
transcript-off, which closes the transcript file. Only one transcript may be
in progress at any time, though some implementations may relax this
restriction. The values returned by these procedures are unspecified.

